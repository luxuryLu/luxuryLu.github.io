{"meta":{"title":"Joe的个人博客","subtitle":null,"description":null,"author":"Joe Lu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"2019年8月小程序开发要点","slug":"2019年8月小程序开发总结","date":"2019-08-26T15:27:28.901Z","updated":"2019-08-26T15:30:58.255Z","comments":true,"path":"2019/08/26/2019年8月小程序开发总结/","link":"","permalink":"http://yoursite.com/2019/08/26/2019年8月小程序开发总结/","excerpt":"","text":"2019年8月小程序开发要点总结标签（空格分隔）： 前端 总结 小程序 要点记录 性能：现象：之前在商详基础内容开发完成之后，明显能感觉到商详页加载过慢，尤其是加价面板，能够清晰地感知到图片的加载过程（图片三分之一三分之一的下载补全）。后期加上视频功能之后，视频的加载也十分慢，而且容易出现卡顿（4G下）。方法：借助腾讯云文档，对图片和视频进行压缩图片质量压缩：https://cloud.tencent.com/document/product/460/36544视频质量压缩：https://cloud.tencent.com/document/product/314/33747重要BUG修复:修复商详页好评图片无法显示的BUG（之前为了性能使用了webp格式，webp格式在ios中无法解析,考虑过只在安卓使用webp，但是部分安卓机型也有不支持webp的情况） 小程序分享相关问题表现：出现过一个BUG，从商详页分享出去的的小程序，接受分享的人点开就无法回到首页（左上角返回icon）原因：左上角返回icon调用的方法是WX.navigationBack, 返回上一个页面 ，从分享点开的用户，页面栈此时只有商详页一个页面。解决方法：控制用户分享时，只分享首路径，同时带上相应参数。用户从分享进入小程序，进入index页面的onLoad生命周期钩子，监测到相应参数，再跳转到商详页。 这个Bug在 拥有二级页面，需要分享 的小程序中应该都会出现。所以如果之后还有新的小程序项目，很有可能碰见相同问题，记录下来，之后遇到相似问题就方便许多。 导航栏 自定义导航栏几乎每个页面都会用到，关于导航栏在不同机型中的高度适配问题，前前后后也是修改了很多次。目前主要自定义导航栏的使用场景主要包括四种（注：小程序右上角的胶囊无法取消显示） 拥有多个tab用于切换（首页商品流） 包含一个自定义的返回icon (商详页) 包含一个自定义的返回icon，以及一个title图片 (模板页) 仅显示一个背景色 (profile) 除了一个相关H5页面的展示，几乎每一个页面都会用到自定义导航栏。自定义导航栏的出现频率实在是很高，相关高度适配工作也很繁琐，在团队开发的时候，也可能会因此编写重复的代码。因此感觉把自定义导航栏抽出作为一个公用组件是很有必要的。 方案和遇到的问题 目前手机屏幕众多，像刘海屏，水滴屏，都会影响我们自定义导航栏距离顶部的距离。 safeArea API(属于 wx.getSystemInfo, wx.getSystemInfoSync)考虑过使用小程序的safeArea API 在竖屏正方向下的安全区域, 然而在实验后发现该API在我自己手机上就出现了问题。小米8，刘海屏。 微信小程序safeArea API返回 的安全区域 的TOP(安全区域左上角纵坐标)竟然为 0{width: 393right: 393top: 0left: 0bottom: 818height: 818}iphone X 中SafeArea bottom也是显示的和screenHeight，windowHeight一样高 wx.getMenuButtonBoundingClientRect() API该API可以获取右上角胶囊的位置，借助该API也许可以完成导航栏高度的自适应然而在浏览 微信开放社区之后，发现该API会经常性的出现bug，包括Ios设备获取胶囊信息全部为0；真机和开发者工具数据不一致等等问题。说明该API目前还是不可信的，如果导航栏的高度依赖该API，很可能样式会出现问题。 statusBarHeight API(属于 wx.getSystemInfo, wx.getSystemInfoSync)wx.getSystemInfo, wx.getSystemInfoSync这两个API可以获取 系统状态栏的高度，系统状态栏高度差异是不同机型导航栏高度差异的重要部分（***刘海屏的刘海也在状态栏里面），微信小程序右上角的胶囊高度是固定的（34px），剩下的差异只在胶囊到状态栏底部的距离，以及胶囊底部到导航栏的底部的距离 目前发现好货中的适配方式使用 getSystemInfo API 中 model，判断机型属于的大类别，为需要适配的元素动态添加相应的类名（xs,plus,normal），编写相应的css。这种方式的一些问题包括（1）我们需要多次传递相应类名直到相应组件 (2) 各个页面都重复地编写了类似的代码，工作重复，不方便维护（3）andorid 类型众多，很难做一个分类，去编写相应的样式，即使能做分类，在每个页面或相应组件 都编写一遍也不太可行。 打算目前打算借助 statusBarHeight 接口，去编写我们的通用的自定义导航栏组件。最主要的原因是 状态栏高度内包含了刘海屏，水滴屏相应 的刘海，水滴的高度。 由于胶囊顶部到状态栏顶部还有差异，设计时，导航栏内容又往往要求和胶囊居中，所以可能同时也会用到 wx.getMenuButtonBoundingClientRect() API","categories":[],"tags":[]},{"title":"2019年7月总结","slug":"2019年7月总结","date":"2019-08-10T17:22:52.506Z","updated":"2019-08-17T15:57:34.605Z","comments":true,"path":"2019/08/11/2019年7月总结/","link":"","permalink":"http://yoursite.com/2019/08/11/2019年7月总结/","excerpt":"","text":"2019年7月总结标签（空格分隔）： 前端 总结 闲谈 回过头来才发现自己已经半年没写博客了，自从开学之后，不是在面试，就是在看面经。等拿到offer之后，又一门心思扎在毕业设计上。回想起来，因为毕业设计和前端还是不属于一个领域，所以那时候学的东西也忘得差不多了。大数据，流计算，Apache Flink，还是属于大数据方向的。当时我还想着这也是留给自己的一个可以选择的方向，现在想起来就觉得其实还是自己想的太理想化了。前端这部分自己业务都还不熟悉，想要联合大数据的学习短时间给自己创造一个价值的提升，还是一个非常艰难的，成本高的，见效慢的事。从头去学习大数据这一块，可能还是得我做前端业务这一块熟练了，再去衡量是否值得去重新学习一块领域。 关于自己未来前端方向 7月份的时候读了这样一篇文章精读《前端未来展望》自己对前端的未来其实没有太深入的理解，但是从这些前端大牛的角度中，还是能窥探出一些东西的。 其实可视化这一块自己确实没有太深入的学习，svg也好，canvas也好。主要可能开始没有”项目驱动”。不过感觉自己和可视化还是挺有缘分的。从在苏州实习，还在用RubyOnRails和JQuery的时候，那个时候就已经开始用Echarts去完成一些业务上的统计需求了，用可视化图表 显示订单数啊，显示交易金额啊。到后来做微博热门话题实时监控的时候，也是用的Echarts去实时显示微博热门话题数据变化，不过这就更简单了，也不过就是一个柱状图或者是条形图。 回过头看这两次经历，实际上满足的需求很简单，就只是柱状图，条形图或者折线图，更何况只是调用一下Echarts的接口。要是这样就敢说自己了解可视化，就实在是太往自己脸上贴金了。 但不管怎么样，在自己前端业务熟练之后，总还要在一个未来的方面专精的，才能以此不断提升自己的竞争力。我自己也开始为自己定制职业规划，以后也会慢慢往里面添加一些细节。 7月都干了啥 7月主要还是入职拼多多，一开始看React文档，后来接到小程序的任务。去看小程序的文档，然后就开始做小程序的业务。一个是已经上线的亲友内购，另一个还没上线，就不在博客里面写了。 7月的思考 / 学习 小程序 小程序还是相对React来说比较简单的，我上手小程序也很快。感觉小程序还是类似Vue, 模板语法什么的。不过关于小程序还是有很多吐槽的。 不支持computed属性（注：官方实现了computed属性的小程序自定义组件扩展 behavior，但是需要小程序基础库版本 &gt;= 2.6.1 的环境。）同时，小程序还不支持传入js语句（不能传入执行一个函数的返回结果）。这就很难受了，我无法根据已经设计好的几个基础状态，进行一些计算，返回我们需要的一个新值/一个组合。这种场景我总是会下意识的想使用computed属性，我感觉这也是使用computed的经典场景。 但是在2.6.1之前用不了，很遗憾。然后我突然发现，一个新的可以实现类似功能的observer属性，我还在想我甚至可以借助这个属性，自己实现类似computed属性的功能。然而仔细一看才发现，observer属性也是2.6.1才支持，官方的computed属性也是借助它实现的。fine~ 后来我传递的时候是给模板语法传递一个新对象{}，在里面写新属性，传递给它我们组件中data里的值。注意，新对象的大括号要和mustcache 语法 中间留一个空格，不然不能正确的将其识别为一个对象。 微信Web开发者工具emmm….哎，自行感受吧，希望之后它会越来越好 业务场景总结(tabbar + 列表页) 一个tabbar在加上一个列表页list，是一个经典的电商场景。就这么一个经典的场景也有很多坑，之前百亿项目H5的同事也和我们分享过他们遇到的坑。我在做新项目的时候确实也遇到了许多相同的坑。本来是只写这一部分的，写着写着又写了很多其它的总结，这一部分先留着，明天再写吧。// 更新于2019/8/17业务场景总结tabbar＋长列表一个滑动吸顶的tabbar加上一个长列表是电商中长常见的一个场景。 但是微信小程序中却不适合做吸顶。为什么？因为小程序中的胶囊是我们无法去做修改的，我们无法控制胶囊的样式(仅黑白两种颜色)，也不能控制胶囊的显示与否，它占据了小程序的右上角。一定，想要做吸顶，tab栏右侧需要留出一定的距离给胶囊，但是这样在非吸顶状态下样式也是非常奇怪。目前的一个设计方案就是放弃吸顶，直接让tab栏固定在头部，右侧留出空间给胶囊。 更早的一个设计方案是tabbar固定在胶囊的下方，胶囊这一行仅仅做一个颜色的填充，(可能左上角会有一个icon承担一些功能)。这种’滑动固定’而非’固顶’，一个是造成了列表展示区的进一步缩小；另一方面，在快速滑动，scroll事件未触发，导致 tabbar上方颜色填充块还未显示出来时，肉眼可以看见列表的内容快速的向上划过去，会造成闪一下的视觉效果。 – 写于2019.8.11– 更新于2019/8/17","categories":[],"tags":[]},{"title":"CSS基础知识点","slug":"CSS基础","date":"2019-02-18T15:00:41.301Z","updated":"2019-02-18T15:01:44.827Z","comments":true,"path":"2019/02/18/CSS基础/","link":"","permalink":"http://yoursite.com/2019/02/18/CSS基础/","excerpt":"","text":"CSS基础 目录 CSS选择器与权重 CSS选择器是如何解析的 display,position 参数 正文CSS选择器与权重 CSS选择器有哪些？通常来讲，有id选择器，类（伪类）选择器，元素（伪元素）选择器，属性选择器，和其他。 他们的权重是如何计算的？权重的大小排列为从 id选择器(A级) 到 类（伪类）选择器；属性选择器（B级） 到 元素（伪元素）选择器（C级）到 其他选择器（D级）。也就是说哪怕有100个类选择器，它的权重依旧没有id选择器高。在id选择器 权重相同的情况下，比较类选择器，属性选择器的权重大小，也就是B级的大小。在类，属性，伪类选择器权重相同的情况下，比较元素选择器，依次往下，比较其他选择器。 除此以外 ！important优先级最高 内联样式比外部样式优先级高 相同权重的情况下后写的样式覆盖之前的 CSS选择器是如何解析的 css选择器是从右往左解析的，这是出于性能的考虑，如果从左往右解析，就需要记住大量的元素。从右往左的话，只需要从一个较小的集合往左依次验证。 盒模型 盒模型其实是CSS学习的一个重要基础。盒模型是页面渲染时，dom元素在页面上的布局模型。一个盒子包括margin(左右)+border(左右)+padding(左右)+content。在标准盒模型下我们对width进行设置，其实设置的是content的宽度。而标准盒模型也就是content-box。而IE盒模型就是border-box，也就是说在这盒模型下设置width,其实设置的是border(左右)+padding(左右)+content的宽度。我们想使用不同的盒模型可以使用box-sizing属性去设置。 display参数/position参数 display属性确定元素的显示类型position属性确定元素的位置 display参数display属性常见的display参数有block,inline,inline-block,none,list-item,table,table-cell,flex,grid等等。将display设置为block,那么这个元素就会表现得像块级元素，这也是div等块级元素标签的默认值。默认会独占一行，宽度默认占满父级元素的百分之百。可以正常设置宽高。display设置为inline,它用来设置行内元素属性。不会单独占一行，设置宽高无效，宽度高度由内容撑开。display: inline-block。行内块级元素。可以让元素既可以像块级元素一样设置宽高，又不会独占一行，比如input输入框，就是inline-block。 display: none用来隐藏某个元素。经常会问到display:none和visibility:hidden的区别 display:list-item可以将元素作为列表显示，display:table和table-cell用于表布局。display:flex是一种很好用的布局，因为在移动端支持较好所以在移动端经常使用。display: grid，网格布局是更加新的一种布局方式。 display是页面布局的一个重要属性，我们做页面布局除了使用浮动以及绝对定位，使用display的一些布局（inline-block布局，table布局，flex布局，grid布局）是非常方便的。 position参数 常见position属性的参数有static,relative,absolute,fixed。还有可能会问到sticky。static是默认值，它不会被特殊的定位。它是遵循标准文档流的。 relative会根据top,bottom,left,right,在自身原来的位置上，做相应的偏移。其他元素的位置不会受其影响。他也是遵循标准文档流，不会改变它原本在文档流的占位空间。 fixed会相对于可视区域/视窗来定位，也是通过top,bottom,left,right来具体定位。它脱离标准文档流，不影响标准文档流元素的布局。 absolute与fixed相类似，只不过它不是根据可视区域来定位，而是根据离自己最近的”positioned”的祖父元素来定位，如果没找到，则相对于body元素。”positioned”元素即position不为static的元素。absolute也是脱离标准文档流，不影响标准文档流元素的布局。但是如果没有设置top,bottom,left,right四个属性中的任意一个的话，它的表现就与relative相同，遵循标准文档流。 另：float也是脱离标准文档流，不影响标准文档流的布局，但是会影响文字流，也就是说虽然不影响其他元素的布局，但是文字会包裹或者说避开它，毕竟float设计出来就是用于这样的用途的。 作为前端学习者，我们也需要对position:sticky这样的属性有一些了解。它能很好的实现一个滑动固顶的一个效果。什么意思呢，就是现在我们点开我们的外卖APP，点击商家的商品详情页，商品列表上方有一个导航。平时它表现得和relative差不多，当我们像下滑动一段距离得时候，我们可以看见我们的导航栏黏在了上方，表现得像一个fixed得元素。目前该属性firefox和safari已经支持，chrome还未支持。 页面布局 页面布局也是前端面试过程中常考的一个点。考察了你的基本功，同时考察了你对新的布局方式是否了解。常见的两栏/三栏布局 我们可以使用 float + margin 绝对定位 table布局 flex布局 grid布局 注意在写float方式的三栏布局的时候我们需要将float:right的元素写在中间那个元素的前面。因为浮动元素尽量向上靠，如果right写在center的后面，center中的内容就会阻碍浮动元素，浮动元素就无法碰到容器的顶部。显示起来就不是我们想要的结果。对于flex布局和grid布局，毫无疑问它们是以后的标准，我们肯定要学习它，更何况flex已经在移动端用的很多了。 两栏&amp;三栏布局这里记录下自己写的两栏布局以及三栏布局的代码因为观看原因，放到文章的最后 圣杯&amp;双飞翼布局圣杯双飞翼布局也是重要的考点。有两位前辈写的很好，这里放出它们的链接。一位总结了它们的起源以及一些区别圣杯双飞翼一位带领我们去实现这两个布局圣杯双飞翼我自己代码也会放到最后 层叠上下文 这里给出一位前辈的文章链接，写的很好，感谢前辈。彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index 水平垂直居中 水平垂直居中 flex布局 flex布局 两栏布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .layout &#123; width: 100%; min-height: 100px; margin:20px 0; &#125; .layout div&#123; min-height: 100px; &#125; .left &#123; background: red; &#125; .main &#123; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;style&gt; .layout.float .left&#123; width: 200px; float: left; &#125; .layout.float .main&#123; margin-left: 200px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; asdasddddddddddddddddddddddddd asdasddddddddddddddddddddddddd &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute&#123; position: relative; &#125; .layout.absolute .left&#123; position: absolute; left: 0; width: 200px; &#125; .layout.absolute .main&#123; left: 200px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; asdasddddddddddddddddddddddddd asdasddddddddddddddddddddddddd &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout flex&quot;&gt; &lt;style&gt; .layout.flex&#123; display: flex; &#125; .layout.flex .left&#123; width: 200px; &#125; .layout.flex .main&#123; flex: 1; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; asdasddddddddddddddddddddddddd asdasddddddddddddddddddddddddd &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table&#123; display: table; &#125; .layout.table .left&#123; display: table-cell; width: 200px; &#125; .layout.table .main&#123; display: table-cell; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; asdasddddddddddddddddddddddddd asdasddddddddddddddddddddddddd &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid&#123; display: grid; grid-template-rows: 100px; grid-template-columns: 200px auto; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;grid&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; asdasddddddddddddddddddddddddd asdasddddddddddddddddddddddddd &lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 三栏布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .layout &#123; margin-top: 20px; width: 100%; height: 100px; &#125; .layout div&#123; min-height: 100px; &#125; .left &#123; width: 300px; background: red; &#125; .right &#123; width: 300px; background: blue; &#125; .center&#123; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;style&gt; .layout.float .left &#123; float: left; &#125; .layout.float .right &#123; float: right; &#125; .layout.float .center &#123; margin-left: 300px; margin-right: 300px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; 浮动 浮动 浮动 浮动 浮动 浮动 浮动 浮动 浮动 浮动 &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute &#123; position: relative; &#125; .layout.absolute .left &#123; position: absolute; left: 0; width: 300px; &#125; .layout.absolute .right &#123; position: absolute; right: 0; width: 300px; &#125; .layout.absolute .center &#123; position: absolute; left: 300px; right: 300px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; 绝对定位 绝对定位 绝对定位 绝对定位 绝对定位 &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout flex&quot;&gt; &lt;style&gt; .layout.flex &#123; display: flex; &#125; .layout.flex .left&#123; width: 300px; &#125; .layout.flex .right&#123; width: 300px; &#125; .layout.flex .center&#123; flex: 1; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; flex flex flex flex flex &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table &#123; display: table; &#125; .layout.table .left&#123; display: table-cell; width: 300px; &#125; .layout.table .right&#123; display: table-cell; width: 300px; &#125; .layout.table .center&#123; display: table-cell; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; table table table table table &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid &#123; display: grid; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; grid grid grid grid grid &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 圣杯双飞翼布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;style&gt; /* *&#123; margin: 0; padding: 0; &#125; .header&#123; height: 100px; background: blue; &#125; .footer&#123; height: 100px; background: blue; &#125; .main&#123; box-sizing: border-box; width: 100%; padding: 0 100px; overflow: hidden; &#125; .main .content&#123; float: left; width: 100%; background: yellow; height: 100px; &#125; .main .left&#123; float: left; width: 100px; background: gray; height: 100px; &#125; .main .right&#123; float: left; width: 100px; background: grey; height: 100px; &#125; .main .left&#123; margin-left: -100%; &#125; .main .right&#123; margin-left: -100px; &#125; .main .left&#123; position: relative; left: -100px; z-index: 99; &#125; .main .right&#123; position: relative; right: -100px; &#125; */ &lt;/style&gt; &lt;div class=&quot;header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;section style=&quot;margin-top:10px&quot;&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .header&#123; height: 100px; background: blue; &#125; .footer&#123; height: 100px; background: blue; &#125; .main&#123; width: 100%; overflow: hidden; &#125; .content-wrapper&#123; float: left; width: 100%; &#125; .content&#123; background: yellow; height: 100px; margin-left: 100px; margin-right: 100px; &#125; .left&#123; float: left; width: 100px; height: 100px; background: grey; margin-left: -100%; &#125; .right&#123; float: left; width: 100px; height: 100px; background: green; margin-left: -100px; &#125; &lt;/style&gt; &lt;div class=&quot;header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;content-wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;1213132132232132123132123123132123132&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"浅谈XSS和CSRF","slug":"浅谈XSS和CSRF","date":"2018-12-16T14:16:32.621Z","updated":"2018-12-16T14:17:03.493Z","comments":true,"path":"2018/12/16/浅谈XSS和CSRF/","link":"","permalink":"http://yoursite.com/2018/12/16/浅谈XSS和CSRF/","excerpt":"","text":"浅谈XSS和CSRF XSS和CSRF是前端比较常见的两种攻击方式，我们作为一个学习者，也需要对这两种攻击方式有所了解 XSS XSS，即跨域脚本攻击，全称Cross Site Scripting。XSS主要分为两种类型。一种是反射型，一种是存储型。比较经典的例子呢，就是评论区。比如说某个站点没有对用户输入的内容进行过滤。那么我们就可以评论 像&lt;script&gt;&lt;/script&gt;这样的文本，中间插入我们攻击的脚本。当然我们也可以评论一个图片&lt;img src=&#39;null&#39; onerror=&quot;这里插入我们攻击的脚本&quot;&gt;。这样所有访问这个页面（带有评论的页面）的用户，都会执行我们的攻击脚本。 预防方式那么我们要怎么预防XSS攻击呢？首先是对用户输入的内容进行转义，就是像单双引号，尖括号这样的内容进行转义。那么浏览器就不会对相应的脚本自动执行。前端也可以进行反转义，并且过滤一些标签或者属性。像script标签，以及像src,onclick这些属性。我们也可以使用CSP，即Content-Security-Policy,csp可以再HTTP Header种进行设置。我们可以限制比如说，只允许加载本站的资源，或者只允许进行访问HTTPs的图片。 CSRF CSRF,即跨站请求伪造，全称Cross-Site-Request-forgery。CSRF攻击是怎么实现的呢?比如说我们访问了一个a站点，登录之后，a站点给我们设置了相应的cookie。这时我们不小心访问了一个攻击用的钓鱼网站，网站中一有一个img标签，它的src就是我们a站点的一个接口。那么我们就会访问这个接口，同时把cookie也发送出去。服务器端验证了cookie,就执行了相应的接口。 预防方式CSRF要怎么预防呢？一种是采用Token验证，就是说，我们网站对用户身份的验证不能光靠cookie.同时也会带有一个Token.如果站点验证Token不正确或者没有Token,那么就拒绝这次请求。还有一种是referer验证，通过http中的referer头，验证http请求的来源，如果不是从本站发起的请求，那么就拒绝它。其实除此之外还可以，通过每次调用接口，都要输入验证码这种方式，这里就不细讲了","categories":[],"tags":[]},{"title":"TLS握手过程","slug":"TLS握手过程","date":"2018-12-07T07:16:21.302Z","updated":"2018-12-07T07:17:20.131Z","comments":true,"path":"2018/12/07/TLS握手过程/","link":"","permalink":"http://yoursite.com/2018/12/07/TLS握手过程/","excerpt":"","text":"TLS握手过程 之前讲了HTTPS原理，那么这次讲一下TLS握手过程。 首先客户端向服务器端发送一个Client Hello，包括一个随机数，客户端支持的加密套件以及SSL版本号等信息。 服务器端收到Client Hello后，发送一个Server Hello消息，服务器端会同样生成一个随机数，同时服务器端会在客户端支持的加密套件中选择一个加密套件。同时服务器会发送他的数字证书。 客户端收到Server Hello之后，对证书进行验证。验证信息正确之后，会生成第三个随机数并使用服务器端的公钥加密，作为预主密钥。（双方使用这三个随机数和加密套件生成主密钥）并且告诉服务器端这边已经切换到之前商量好的加密套件，最后会发送一段Finish消息给服务器端 服务器端最后会有个回应告诉客户端，这边已经切换到之前商量好的加密套件，并发送一个Finish消息。 之后双方就可以使用主密钥正常的传输了。 当然还有一些False Start（抢跑）和 通过Session ID恢复连接，就不细讲了。","categories":[],"tags":[]},{"title":"HTTPS原理学习","slug":"HTTPS原理学习","date":"2018-12-06T14:03:53.955Z","updated":"2018-12-06T14:04:22.892Z","comments":true,"path":"2018/12/06/HTTPS原理学习/","link":"","permalink":"http://yoursite.com/2018/12/06/HTTPS原理学习/","excerpt":"","text":"HTTPS原理学习 因为HTTP是明文传输的，是不安全的，这才有了HTTPS。HTTPS是在TCP层上多了一个SSL/TLS层，也就是说HTTPS是在SSL/TLS层上的HTTP。 对称加密 那么HTTPS是怎样做到安全传输信息的呢，首先讲一下对称加密。既然HTTP是明文传输，我们很自然地就想到进行加密。加密和解密使用同一个密钥的加密方式就是对称加密。那么对称加密有什么问题呢，当我们的攻击者拿到了这个密钥，那么我们的加密对于他来说就是透明的。所以我们的非对称加密这时就有用了。 非对称加密 那么什么是非对称加密，非对称加密是我们有一个公钥和私钥，它们为一对。公钥加密的信息只有私钥能解密。而私钥只保存在服务器，不向外传输。所以中间人即使拿到了信息和公钥，也没法对信息解密。 非对称加密的问题 但是，非对称加密还有一个问题，就是服务器在传输公钥的时候，被中间人篡改，给替换成中间人自己的公钥。那么客户端以为这是服务器的公钥，就用这个公钥进行加密，而中间人则用他自己的私钥进行解密，还可以对解密后的信息使用真正服务器的公钥进行加密 CA和证书 那么我们就要解决非对称加密的公钥被篡改这个问题。HTTPS中使用了数字证书和数字签名去解决这个问题。我们需要到权威的CA去进行进行申请，CA验证通过了，就会将我们服务器这边的公钥和相关信息使用CA的私钥加密生成数字签名，数字证书中包括我们的公钥，信息以及数字签名。这样如果中间人篡改了公钥，我们在对数字签名进行解密之后，就会发现数据不匹配。当然中间人也可以把公钥，信息和数字签名都换成自己的，但是这样虽然信息匹配了，但是客户端即浏览器就会发现这不是我们想要访问的节点了。还有一点就是CA的公钥一般是预置在浏览器的。不然这个问题就变成鸡生蛋，蛋生鸡的问题了。正如那句话所说，“难的不是加密，而是密钥的保管。” PS 希望这篇文章对你有帮助，可能有图会更好理解，以后我应该会去试着使用一些图床。","categories":[],"tags":[]},{"title":"再谈作用域","slug":"再谈作用域","date":"2018-11-06T17:11:55.917Z","updated":"2018-11-06T17:11:34.392Z","comments":true,"path":"2018/11/07/再谈作用域/","link":"","permalink":"http://yoursite.com/2018/11/07/再谈作用域/","excerpt":"","text":"再谈作用域 说实话，前一段时间，深入地读了一些前辈的文章之后，我对作用域链，执行上下文等一些概念确实有了一些深入的认识，但是我很不安，因为我确实无法理解作用域，也不能说完全不理解，是那种说不清，道不明，只可意会不可言传的感觉。它成了我心头的一根刺。晚上实在难受，还是想着看看别人的文章，文章看着看着突然就有了一种突然开窍的感觉。在这里记录下自己的想法： ###什么是作用域作用域就是 变量，函数 可访问的范围。很明显 这句话比之前的说法更好理解（对于理解后的自己来说） 嗯，还是用代码举具体例子 比如下面123456789101112var a = 1;function turn (num) &#123; var b = 2; c = 3; a //1 b //2 c //3&#125;a //1b //Uncaught ReferenceError: b is not defined at &lt;anonymous&gt;:1:1c //3 a是在程序最外层定义的，c没有声明直接赋值。它们俩都有全局作用域，因此在整个程序内都可以访问 那b呢?它是在函数 turn里面定义的，它拥有函数作用域，也就是说在函数turn里面都可以访问到它如果是闭包的情况呢，我们修改一下代码12345678910111213141516var a = 1;function turn (num) &#123; var b = 2; c = 3; a //1 b //2 c //3 function change () &#123; var d = b * b; //4 (2 * 2) return d &#125;&#125;a //1b //Uncaught ReferenceError: b is not defined at &lt;anonymous&gt;:1:1c //3 change函数里面依旧是可以访问到b变量，因为change函数也在turn函数里面，在turn函数里面都可以访问b，这也说明了JS的作用域是词法作用域。 作用域和作用域链是什么关系你想啊，我们知道这个变量的作用域（词法），JS引擎又不知道（应该是知道的，引入下一句话），那它要怎么知道呢?比如代码运行到某个上下文中，它要怎么知道我可以不可以访问这个变量呢，这个时候，他就要到作用域链中去查找。我的看法是 作用域只是一种抽象的概念，内存中不会存储变量的作用范围，（不然你想啊，如果要直接往变量的内存 存可以作用域的范围，全局变量的引用就几千个了吧，函数写了也可以不调用，所以这种直接存作用范围的方式是不行的）（记住，作用域没有直接的代码或者内存体现）而作用域链机制 就是一种对 JS词法作用域的一种实现（规定上下文能访问的变量范围，从另一维度上看不就是规定了变量的可（被）访问范围吗）","categories":[],"tags":[]},{"title":"作用域， 上下文 和 变量的查找","slug":"作用域， 上下文 和 变量的查找","date":"2018-11-01T07:20:33.727Z","updated":"2018-11-06T17:17:54.050Z","comments":true,"path":"2018/11/01/作用域， 上下文 和 变量的查找/","link":"","permalink":"http://yoursite.com/2018/11/01/作用域， 上下文 和 变量的查找/","excerpt":"","text":"作用域， 上下文 和 变量的查找 之前一直以为自己理解作用域链和上下文了，知道后来去看了别人的博客，才发现自己理解的很肤浅。作为一个笔记写下自己的理解吧。第一部分我会说一下 一个例子的执行过程，涉及到作用域链，上下文变量对象。第二部分我会说一下和作用域，上下文有关的面试中可能会问到的题目，当然只是我自己目前的理解。 一个例子的执行过程123456789var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 1.首先创建全局上下文，全局上下文压入 上下文执行栈。12345//伪代码ECS.push(全局上下文globalContext)；即 ECS = [ globalConext] 2.初始化全局上下文，12345全局上下文Gobalcontext = &#123; 变量对象VO : &#123;global全局对象&#125;, 作用域Scope : [globalContext.VO], this：globalContext.vo&#125; 初始化全局上下文的同时，创建函数checkscope，为它分配内存的时侯，把作用域Scope赋值给checkscope函数的[[scope]]内部属性。 3.全局上下文执行可执行代码，执行到调用checkscope函数的时候。生成checkscope函数上下文，将checkscope函数上下文压入 上下文执行栈。此时1234ECS = [globalContext;checkscope的Context;] 4.然后初始化checkscope函数上下文，包括， a. 先把之前赋值过的[[scope]]内部属性赋值给 作用域链scope b. 然后用arguments创建活动对象AO。 c. 初始化活动对象AO，进行一些形参声明，变量声明，函数声明 d. 将当前活动对象放到作用域链的前端同时创建了函数f, 将当前作用域链scope赋值给他的[[scope]]属性（之前我在想是初始化活动对象AO的时候函数f的[[scope]]属性赋值吗，不然怎么叫同时，但是后来我又想如果那个时候赋值，checkscope函数的活动对象还没放到作用域链的前端，那不就出问题了吗？再后来，我就觉得，他什么时候赋值不重要，因为给函数f[[scope]]属性的赋值应该是个‘引用(地址)赋值’，checkscope函数上下文的作用域链Scope应该也是各引用，所以就不重要了） 5.然后执行代码 6.然后 return了一个函数 ，checkscope函数上下文弹出 执行上下文栈 7.然后执行全局上下文的代码，发现进行了f函数的调用 8.然后生成f函数上下文，f函数上下文被推入 执行上下文栈 9.。。。然后就类似checkscope函数，。。。最后f函数上下文弹出上下文执行栈 10.最后全局上下文弹出上下文执行栈。 与作用域上下文相关的题目1.什么是作用域？作用域是 变量，函数 可(被)访问的范围js中使用的是词法作用域（静态作用域），也就是说作用域在函数定义的时候就已经确定了2.引擎怎樣找到一個變量js引擎在执行代码前会做一个准备工作，会创建上下文环境。上下文有三个重要的属性，一个是变量对象VO，一个是作用域链，一个是thisjs引擎维护了一个上下文执行栈， 我们从当前执行上下文出发，沿着当前上下文的作用域链不断向上查找，直到查到全局上下文为止。3.作用域和上下文的區別作用域在函数定义的时候就已经确定了，上下文要在函数调用执行阶段才确定。 extra我发现有时候想要深入了解一些原理，只靠一本书是不够的，还要翻阅多本书，多个文档。如果不好理解，还需要去看一下别人的博客，看看他们怎么理解。感谢前辈们的贡献 参考链接JavaScript深入之词法作用域和动态作用域JavaScript深入之执行上下文","categories":[],"tags":[]},{"title":"JS中的面向对象，原型链和继承","slug":"JS中的面向对象，原型链和继承","date":"2018-10-31T07:06:04.192Z","updated":"2018-10-31T07:06:47.148Z","comments":true,"path":"2018/10/31/JS中的面向对象，原型链和继承/","link":"","permalink":"http://yoursite.com/2018/10/31/JS中的面向对象，原型链和继承/","excerpt":"","text":"JS中的面向对象，原型链和继承 面向对象理解只是我自己目前的一些理解，以后也许会修改。面向对象是一种抽象方式。把现实生活中的物体看作一个个‘对象’，这样我们在写实际应用的时候，就可以将现实生活中的 概念/模型 映射到计算机领域的数据结构。具有类似属性一些物体我们就将它们归为一类，产生类的概念。而被归为一类的物体中，里面还有一些物体它们也有相似的地方，还可以抽象成一个类，这样就形成父类和子类，也就引出了继承。 JS中的面向对象JS在ES6之前没有class的机制，ES6之后实现了class，当然它的本质也是语法糖，封装起来还是不错的。不过，我们作为一个学习者，还是要学习JS封装和继承的实际实现。我推荐大家还是读一读《JavaScript 高级程序设计》中的 “面向对象的程序设计”那一章，讲的还是不错的。我会挑我觉得比较经典的谈谈我的看法。 创建对象/封装虽然ES6之前没有class,但是object本身就是js基本类型之一。当然我们不可能每一次都用字面量或者Object()构造对象。所以我们引入了设计模式。像工厂模式，构造函数模式，原型模式，组合使用构造函数模式和原型模式，动态原型模式，寄生构造函数模式，稳妥构造模式。我个人还是倾向组合使用构造函数和原型模式。不过在讲之前我们先来说一下构造函数和原型。 构造函数123456function User (id, balance = 0) &#123; this.id = id; this.balance = balance;&#125;var user1 = new User(1, 100); // 像这样一个函数就是一个构造函数，它构造出来的对象 比如User1，检查 User1 instanceof User 返回为true。 使用new创建对象的过程是怎样的呢，这有时也会作为面试题被问到 new 新建一个空的Object 将构造函数的作用域赋给新对象，改变this的指向 执行构造函数 返回修改后的对象 原型你看，我们都打算将一部分具有类似属性和方法的对象抽象出来了，那些类似的属性和方法总不能还由那些对象自己放着吧，那样多浪费内存啊。我们得将类似的属性和方法放到一个地方，这些对象都能访问到，所以prototype（原型）就出场了。 prototype是每个函数都会有的属性，它指向一个Prototype对象，该原型对象也有一个constructor属性指向相应的函数。用构造函数构造出来的对象除了构造函数中添加的那些属性，还有一个[[prototype]]属性指向，构造函数的prototype。当我们查找一个对象的属性，比如在我们的user1中找一个叫name的属性，js引擎在user1对象上找不到呀，那怎么办呢？这时，js引擎就会到[[prototype]]指向的对象上找，如果找到了就返回，没找到呢？那就沿着这个原型的[[prototype]]继续往找，直到Object.prtotype为止。 所以我们就把一些相似的属性或者方法放在prototype，如下图。那为什么下面只有一些方法放在prototype里面了。这就是组合使用构造函数和原型模式。我们不能把相同的方法放构造函数里面，这已经说过了，因为浪费内存。但是属性呢？你想啊，虽然你们都有name这个属性，如果都放prototype里面，那你们不都成一个名字了？（当然，你可以手动给新构造的函数赋值来屏蔽原型中同名的属性，也可以在构造函数中赋值来屏蔽原型中的同名属性，不过何必呢，）所以除了本来就是共享一个值的属性，属性的赋值还是得放在构造函数里。123456789101112131415function User (id, name, balance = 0) &#123; this.id = id; this.name = name; this.balance = balance;&#125;User.prototype = &#123; constructor : User, saveMoney: function (amount) &#123; this.money += amount; &#125;, withdrawMoney: function (amount) &#123; this.money -= amount; &#125;&#125; 继承JS主要通过原型链实现继承，其实如果理解了对象属性的查找就比较好理解原型链。就, 子类的prototype的[[prototype]]属性指向父类的prototype，就这样一直指指指，直到Object.prototype嘛。J S高级程序设计中讲到的继承模式有许多，我认为比较经典的是组合继承和寄生组合是继承。这里内容太多，不做细讲，推荐大家去看红宝书(再次安利) 放一下我的例子吧123456789101112131415161718192021222324252627282930function User (id, name, balance = 0) &#123; this.id = id; this.name = name; this.balance = balance;&#125;var User1 = new User(1, 100);User.prototype = &#123; constructor : User, saveMoney: function (amount) &#123; this.money += amount; &#125;, withdrawMoney: function (amount) &#123; this.money -= amount; &#125;&#125;function SuperUser (id, name, balance, vipTime) &#123; User.call(this, id, name, balance); this.vipTime = vipTime;&#125;function F () &#123;&#125;F.prototype = User.prototype;SuperUser.prototype = new F();SuperUser.prototype.constructor = SuperUser;SuperUser.prototype.getDiscount = function () &#123; console.log(&apos;get discount&apos;);&#125; 这里子类的构造函数借用了父类的构造函数，关于子类原型，先构造了一个空函数，然后将User.prototype 赋值给 F.prototype,然后将F函数创建的匿名对象赋值给子类的原型。因为子类的原型是由F函数构建的，所以constructor为F,我们不希望它这样，所以修正constructor属性，最后为子类的原型添上一些方法。 （这里只是对上面代码的说明，如果看不懂，或者有一些疑问比如为什么不直接将父类的Prototype赋给子类的prototype，还是推荐看红宝书，因为本人水平有限可能将的不是特别的好，而且真要说清楚，篇幅还蛮长的） 继承函数的封装红宝书中的寄生组合式继承 抽象出来的继承方法借用原型式中oject()函数，其实只是为了实现寄生组合式继承没必要再引入一个函数，用下面的函数也可以123456function inherits(Child, Parent) &#123; function F() &#123;&#125; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;","categories":[],"tags":[]},{"title":"$(document).ready()和window.onload()的区别","slug":"$(document).ready()和window.onload()的区别","date":"2018-10-30T08:09:25.818Z","updated":"2018-10-31T07:01:07.427Z","comments":true,"path":"2018/10/30/$(document).ready()和window.onload()的区别/","link":"","permalink":"http://yoursite.com/2018/10/30/$(document).ready()和window.onload()的区别/","excerpt":"","text":"$(document).ready()和window.onload()的区别 $(document).ready()和window.onload()的区别首先 $(document).ready() 是JQuery中的方法12345678$(function()&#123;&#125;);jQuery(document).ready(function()&#123;&#125;);$(document).ready(function()&#123;&#125;);$(document).on(&apos;ready&apos;, function()&#123;&#125;); 这四种事件是一样的$可以换成JQuery，document是默认对象，ready是默认事件，可以不写 $(document).ready()在dom构建完成之后执行而 window.onload()则在页面所有资源加载完成后执行window.onload()触发发生在$(document).ready()之后 PS这篇文章其实我也没写下什么又用的东西，可能是最近感觉自己好多东西不会，有些急了，还是要调整好心态呀 :)anyway，还是可以参考下面的链接，写的还是不错的。 参考链接jQuery - What are differences between \\$(document).ready and $(window).load? - Stack Overflow简述domready和onload事件的区别 - 简书document.ready和window.onload的区别 - Hopefully Sky的博客 - CSDN博客","categories":[],"tags":[]},{"title":"谈谈 事件","slug":"谈谈 事件","date":"2018-10-24T06:07:10.540Z","updated":"2018-10-24T06:16:21.749Z","comments":true,"path":"2018/10/24/谈谈 事件/","link":"","permalink":"http://yoursite.com/2018/10/24/谈谈 事件/","excerpt":"","text":"谈谈 事件 最近在读红宝书，就是那本JavaScript高级程序设计。读到事件那一章，碰巧又看到一部分和事件有关的面试题，于是写下这篇文章当作自己的学习笔记。 事件流 在没有阅读相关文章之前，我都一直以为一个元素的onclick就只是对应这个元素的点击事件。红宝书中提出的问题就是 当你单击了某个元素时，是否也点击了它的父元素呢？当然，原文是用同心圆来做说明的。想象一张纸上有一组同心圆，当你把手放在圆心时，手指指向的不是一个圆，而是纸上所有的圆。事件流描述的是从页面接受事件的顺序。IE事件流是事件冒泡，即从最具体的元素，逐级向上传播。NetScape提出的事件流是事件捕获，即从不太具体的元素到具体的元素。而 DOM2级事件 规定的事件流包括三个阶段： 事件捕获阶段，处于目标阶段和事件冒泡阶段。 事件代理，事件委托 理解了事件流之后，其实就比较好理解事件代理。什么是事件代理呢？举个例子，我们有一个5*5的table,我们要实现一个功能就是点击某个tablecell时，将里面的文本经过某些处理输出到控制台。如果不使用事件代理，那么我们很可能写一个循环，然后对每一个tablecell设置onclick。这样当然可以，但是要知道添加到页面上的数据处理程序数量将直接影响到页面整体的性能。在循环里面为每个dom设置匿名函数显然是不可取的，这会消耗大量的内存。当然，你也可以提前写好一个通用的函数，再在循环中将函数绑定到相应的事件中。但是多次dom访问操作也是极其消耗性能的，所以事件委托是一个较好的方案。事件委托利用了事件冒泡，指定一个事件处理程序，就可以管理某一类型的所有事件。比如之前的例子，我们就写一个通用的处理函数，然后让table去监听click事件，在table的事件监听器中处理函数。而且使用事件委托之后，一旦你想要添加新的元素进去，它也能正常响应原先的事件。如果不用事件响应的话，添加dom之后，还得再次手动为这些dom添加事件处理程序。 绑定事件的方式绑定事件有三种方式。第一种是在html中进行事件绑定，即在html标签的onclick等等属性上绑定事件。这种方式会导致一个问题就是html代码和js代码紧密耦合，不利于维护。第二种是 DOM0级事件处理程序，即在dom元素的expando属性上绑定。如 var a = document.getElementById(&#39;app&#39;); a.onclick = someFunction();这种形式绑定事件不如DOM2级，因为容易导致事件相互覆盖。第三种 是DOM2级事件处理程序,如var btn = document.getElementById(&#39;myBtn&#39;); btn.addEventListener(&quot;click&quot;, function() { alert(this.id); }, false);最后一个参数建议尽量使用false，因为：标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。同时，建议在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。 Some我们可以使用 event.preventDafault()方法阻止默认事件。如果想查看默认事件是否被阻止了，可以使用event.defaultPrevented属性查看。 如果需要阻止事件的传播，可以使用event.stopPropagation()方法。","categories":[],"tags":[]},{"title":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","slug":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","date":"2018-10-14T04:40:38.662Z","updated":"2018-10-14T04:52:55.111Z","comments":true,"path":"2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","link":"","permalink":"http://yoursite.com/2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","excerpt":"","text":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题 还记得刚开始接触前端的时候，那时候第一次看到 0.1 + 0.2 !== 0.3 的时候还是比较惊讶的，但那时候的我一心只想学习一些新技术、新框架，只想快速上手，自动地把这些问题归为底层的问题，便抛之脑后了。等到再一次碰到类似的问题，已经是几个月后了。 Number的存储 在讨论为什么 0.1 + 0.2 !== 0.3 之前，我们先来看看数字在JS中是怎么存储的吧。我们都知道在JS中数字只有一种数据类型就是 Number， 而 Number 实际上是一种双精度浮点数的数据类型，遵循(IEEE - 754)标准 ，用64bit进行存储。 双精度浮点数存储格式 从左往右依次为sign bit(符号): 用来表示正负号 exponent(指数): 用来表示次方数 mantissa(尾数): 用来表示精确度 在我不了解它的数字表示之前，我考虑的是mantissa表示尾数，那么小数点应该存放在哪里，怎么存放？后来，我才明白，小数点不用存，你可以把它看成小数点在尾数mantissa的最左边，即52bit和51bit之间，为什么会这样呢？ 事实上，为了最大限度提高精确度，可以要求尾数规格化，把尾数处理到大于等于1而小于2的区间内，便可省去前述的“1” 相当于尾数mantissa部分左侧多了一个“1.”还不用占用空间。比如尾数mantissa中存了52个1那么尾数mantissa实际表示的值（二进制）即为1.11…111(小数点后52个1)$$ mantissa = 1.11…111 $$转换成十进制即$$ mantissa = 1+ (1/2)^1 + (1/2)^2 + … + (1/2)^{51} + (1/2)^{52} $$ 与此同时，我们正常理解指数部分应该为$$ 2^{exponent} $$exponent即为62bit到52位的正常二进制表示但实际上我们的exponent 还有一个片偏移量所以指数部分实际表示的值还要减去0x3ff那么指数部分实际表示的值为$$ 2^{exponent-0x3ff} $$ 那么这64bit实际表示的数字为$$ (-1)^{sign} \\times 1.mantissa \\times 2^{exponent-0x3ff} $$ 回到 0.1 + 0.2 那么回到 0.1 + 0.2 这个问题上，我们看看0.1和0.2实际存储情况是怎么样的。我们先看0.1123456789101112130.1 * 2 = 0.2 //00.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //0... 你可以看到它是乘不完的，0011这四个数在循环，即0.1转换成二进制是无限循环的。但是要知道，我们的尾数部分只有52位，多的部分只能截掉。也就是说十进制的0.1在存储为双精度浮点数的时候会造成精度丢失。 而精度丢失丢失正是我们今天这个问题的原因所在1234567// 0.1 的存储形式0.00011001100110011001100110011001100110011001100110011010 // 0.2 的存储形式0.0011001100110011001100110011001100110011001100110011010 // 二进制相加的结果0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 其他语言的通病 事实上，这不是JS才有的问题，毕竟Number类型是按照IEEE - 754标准的双精度浮点数实现的，这个问题在所有按照标准实现的语言中都有可能出现。 在我前一段时间写的项目中，我发现表格中一个金额显示为“30635.839999999997”，想了一会觉得应该是JavaScipt中Number丢失精度的问题。后来查看日志发现不是，而是Rails后端接口传过来的数据就是“30635.839999999997”，在后端进行double类型相加运算的时候，就已经出现了问题。起码这已经能证明这个问题不是JavaScript的原因。 解决问题案例 正如上面提到的那样，我之前的一个项目中，发现表格中一个金额显示为“30635.839999999997”，这个显示数据肯定不行的。发现之后，我一开始打算直接粗暴地给表格所有数据加上toFixed(2)完事，这样的修改是最不用动脑子的。但是这样是行不通的，一个是我想要整数和一位小数只显示他们原来的样子。比如“500”就显示成“500”而不是”500.00”。另外toFixed()方法本身也有问题，不能正常地进行四舍五入。 这里我使用了他人的一个方法(链接位于文末)12345678910数据展示类当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True封装成方法就是：function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision));&#125;为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。 我在js需要处理相关数据的地方中调用这个函数，大体是能解决这个问题的。 当然工作中碰到精度问题的情景不可能只有这一个，如果需要专业的解决方法，我们可以使用mathjs。 不管怎么样，理解了0.1 + 0.2 !== 0.3的原因，起码以后遇到类似问题，就能快速定位到原因所在。 参考链接 双精度浮点数 - 维基百科，自由的百科全书JavaScript 浮点数陷阱及解法","categories":[],"tags":[]}]}