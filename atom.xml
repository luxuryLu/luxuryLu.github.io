<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-13T07:26:26.924Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Joe Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/14/%E4%BB%8E%200.1%20+%200.2%20!==%200.3%20%E5%BC%80%E5%A7%8B%20%E8%B0%88%E8%B0%88JavaScript%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/</id>
    <published>2018-10-14T04:40:38.662Z</published>
    <updated>2018-10-13T07:26:26.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-0-1-0-2-0-3-开始-谈谈JavaScript精度问题"><a href="#从-0-1-0-2-0-3-开始-谈谈JavaScript精度问题" class="headerlink" title="从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题"></a>从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题</h1><hr><p>还记得刚开始接触前端的时候，那时候第一次看到 0.1 + 0.2 !== 0.3 的时候还是比较惊讶的，但那时候的我一心只想学习一些新技术、新框架，只想快速上手，自动地把这些问题归为底层的问题，便抛之脑后了。等到再一次碰到类似的问题，已经是几个月后了。<br><br></p><h2 id="Number的存储"><a href="#Number的存储" class="headerlink" title="Number的存储"></a>Number的存储</h2><hr><p>在讨论为什么 0.1 + 0.2 !== 0.3 之前，我们先来看看数字在JS中是怎么存储的吧。<br>我们都知道在JS中数字只有一种数据类型就是 Number， 而 Number 实际上是一种双精度浮点数的数据类型，遵循<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank" rel="noopener">(IEEE - 754)</a>标准 ，用64bit进行存储。<br><br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png" alt="双精度浮点数存储格式" title="">                </div>                <div class="image-caption">双精度浮点数存储格式</div>            </figure></p><p>从左往右依次为<br>sign bit(符号): 用来表示正负号</p><p>exponent(指数): 用来表示次方数</p><p>mantissa(尾数): 用来表示精确度</p><hr><p>在我不了解它的数字表示之前，我考虑的是mantissa表示尾数，那么小数点应该存放在哪里，怎么存放？<br>后来，我才明白，小数点不用存，你可以把它看成小数点在尾数mantissa的最左边，即52bit和51bit之间，为什么会这样呢？</p><blockquote><p>事实上，为了最大限度提高精确度，可以要求尾数规格化，把尾数处理到大于等于1而小于2的区间内，便可省去前述的“1”</p></blockquote><p>相当于尾数mantissa部分左侧多了一个“1.”还不用占用空间。<br>比如尾数mantissa中存了52个1<br>那么尾数mantissa实际表示的值（二进制）即为1.11…111(小数点后52个1)<br>$$ mantissa = 1.11…111 $$<br>转换成十进制即<br>$$ mantissa = 1+ (1/2)^1 + (1/2)^2 + … + (1/2)^{51} + (1/2)^{52}  $$</p><p>与此同时，我们正常理解指数部分应该为<br>$$ 2^{exponent} $$<br>exponent即为62bit到52位的正常二进制表示<br>但实际上我们的exponent 还有一个片偏移量<br>所以指数部分实际表示的值还要减去0x3ff<br>那么指数部分实际表示的值为<br>$$ 2^{exponent-0x3ff} $$</p><p><strong>那么这64bit实际表示的数字为</strong><br>$$ (-1)^{sign} \times 1.mantissa \times 2^{exponent-0x3ff} $$<br><br></p><h2 id="回到-0-1-0-2"><a href="#回到-0-1-0-2" class="headerlink" title="回到 0.1 + 0.2"></a>回到 0.1 + 0.2</h2><hr><p>那么回到 0.1 + 0.2 这个问题上，我们看看0.1和0.2实际存储情况是怎么样的。<br>我们先看0.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0.1 * 2 = 0.2    //0</span><br><span class="line">0.2 * 2 = 0.4    //0</span><br><span class="line">0.4 * 2 = 0.8    //0</span><br><span class="line">0.8 * 2 = 1.6    //1</span><br><span class="line">0.6 * 2 = 1.2    //1</span><br><span class="line">0.2 * 2 = 0.4    //0</span><br><span class="line">0.4 * 2 = 0.8    //0</span><br><span class="line">0.8 * 2 = 1.6    //1</span><br><span class="line">0.6 * 2 = 1.2    //1</span><br><span class="line">0.2 * 2 = 0.4    //0</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure></p><p>你可以看到它是乘不完的，0011这四个数在循环，即0.1转换成二进制是无限循环的。<br>但是要知道，我们的尾数部分只有52位，多的部分只能截掉。<br>也就是说十进制的0.1在存储为双精度浮点数的时候会造成精度丢失。</p><p><strong>而精度丢失丢失正是我们今天这个问题的原因所在</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 0.1 的存储形式</span><br><span class="line">0.00011001100110011001100110011001100110011001100110011010 </span><br><span class="line">// 0.2 的存储形式</span><br><span class="line">0.0011001100110011001100110011001100110011001100110011010 </span><br><span class="line">// 二进制相加的结果</span><br><span class="line">0.0100110011001100110011001100110011001100110011001100111</span><br><span class="line">// 转成十进制正好是 0.30000000000000004</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="其他语言的通病"><a href="#其他语言的通病" class="headerlink" title="其他语言的通病"></a>其他语言的通病</h2><hr><p>事实上，这不是JS才有的问题，毕竟Number类型是按照IEEE - 754标准的双精度浮点数实现的，这个问题在所有按照标准实现的语言中都有可能出现。</p><p>在我前一段时间写的项目中，我发现表格中一个金额显示为“30635.839999999997”，想了一会觉得应该是JavaScipt中Number丢失精度的问题。后来查看日志发现不是，而是Rails后端接口传过来的数据就是“30635.839999999997”，在后端进行double类型相加运算的时候，就已经出现了问题。<br>起码这已经能证明这个问题不是JavaScript的原因。</p><h2 id="解决问题案例"><a href="#解决问题案例" class="headerlink" title="解决问题案例"></a>解决问题案例</h2><hr><p>正如上面提到的那样，我之前的一个项目中，发现表格中一个金额显示为“30635.839999999997”，这个显示数据肯定不行的。发现之后，我一开始打算直接粗暴地给表格所有数据加上toFixed(2)完事，这样的修改是最不用动脑子的。<br>但是这样是行不通的，一个是我想要整数和一位小数只显示他们原来的样子。比如“500”就显示成“500”而不是”500.00”。另外toFixed()方法本身也有问题，不能正常地进行四舍五入。</p><p>这里我使用了他人的一个方法(链接位于文末)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数据展示类</span><br><span class="line">当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：</span><br><span class="line"></span><br><span class="line">parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True</span><br><span class="line">封装成方法就是：</span><br><span class="line"></span><br><span class="line">function strip(num, precision = 12) &#123;</span><br><span class="line">  return +parseFloat(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br><span class="line">为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。</span><br></pre></td></tr></table></figure></p><p>我在js需要处理相关数据的地方中调用这个函数，大体是能解决这个问题的。</p><p>当然工作中碰到精度问题的情景不可能只有这一个，如果需要专业的解决方法，我们可以使用mathjs。</p><p>不管怎么样，理解了0.1 + 0.2 !== 0.3的原因，起码以后遇到类似问题，就能快速定位到原因所在。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr><p><a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8" target="_blank" rel="noopener">双精度浮点数 - 维基百科，自由的百科全书</a><br><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">JavaScript 浮点数陷阱及解法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从-0-1-0-2-0-3-开始-谈谈JavaScript精度问题&quot;&gt;&lt;a href=&quot;#从-0-1-0-2-0-3-开始-谈谈JavaScript精度问题&quot; class=&quot;headerlink&quot; title=&quot;从 0.1 + 0.2 !== 0.3 开始 谈谈J
      
    
    </summary>
    
    
  </entry>
  
</feed>
