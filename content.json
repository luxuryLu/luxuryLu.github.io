{"meta":{"title":"Joe的个人博客","subtitle":null,"description":null,"author":"Joe Lu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"作用域， 上下文 和 变量的查找","slug":"作用域， 上下文 和 变量的查找","date":"2018-11-01T07:20:33.727Z","updated":"2018-11-01T07:20:16.683Z","comments":true,"path":"2018/11/01/作用域， 上下文 和 变量的查找/","link":"","permalink":"http://yoursite.com/2018/11/01/作用域， 上下文 和 变量的查找/","excerpt":"","text":"作用域， 上下文 和 变量的查找 之前一直以为自己理解作用域链和上下文了，知道后来去看了别人的博客，才发现自己理解的很肤浅。作为一个笔记写下自己的理解吧。第一部分我会说一下 一个例子的执行过程，涉及到作用域链，上下文变量对象。第二部分我会说一下和作用域，上下文有关的面试中可能会问到的题目，当然只是我自己目前的理解。 一个例子的执行过程123456789var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 1.首先创建全局上下文，全局上下文压入 上下文执行栈。12345//伪代码ECS.push(全局上下文globalContext)；即 ECS = [ globalConext] 2.初始化全局上下文，12345全局上下文Gobalcontext = &#123; 变量对象VO : &#123;global全局对象&#125;, 作用域Scope : [globalContext.VO], this：globalContext.vo&#125; 初始化全局上下文的同时，创建函数checkscope，为它分配内存的时侯，把作用域Scope赋值给checkscope函数的[[scope]]内部属性。 3.全局上下文执行可执行代码，执行到调用checkscope函数的时候。生成checkscope函数上下文，将checkscope函数上下文压入 上下文执行栈。此时1234ECS = [globalContext;checkscope的Context;] 4.然后初始化checkscope函数上下文，包括， a. 先把之前赋值过的[[scope]]内部属性赋值给 作用域链scope b. 然后用arguments创建活动对象AO。 c. 初始化活动对象AO，进行一些形参声明，变量声明，函数声明 d. 将当前活动对象放到作用域链的前端同时创建了函数f, 将当前作用域链scope赋值给他的[[scope]]属性（之前我在想是初始化活动对象AO的时候函数f的[[scope]]属性赋值吗，不然怎么叫同时，但是后来我又想如果那个时候赋值，checkscope函数的活动对象还没放到作用域链的前端，那不就出问题了吗？再后来，我就觉得，他什么时候赋值不重要，因为给函数f[[scope]]属性的赋值应该是个‘引用(地址)赋值’，checkscope函数上下文的作用域链Scope应该也是各引用，所以就不重要了） 5.然后执行代码 6.然后 return了一个函数 ，checkscope函数上下文弹出 执行上下文栈 7.然后执行全局上下文的代码，发现进行了f函数的调用 8.然后生成f函数上下文，f函数上下文被推入 执行上下文栈 9.。。。然后就类似checkscope函数，。。。最后f函数上下文弹出上下文执行栈 10.最后全局上下文弹出上下文执行栈。 与作用域上下文相关的题目1.什么是作用域？作用域是代码定义变量的范围，它规定了代码如何查找变量js中使用的是词法作用域（静态作用域），也就是说作用域在函数定义的时候就已经确定了2.引擎怎樣找到一個變量js引擎在执行代码前会做一个准备工作，会创建上下文环境。上下文有三个重要的属性，一个是变量对象VO，一个是作用域链，一个是thisjs引擎维护了一个上下文执行栈， 我们从当前执行上下文出发，沿着当前上下文的作用域链不断向上查找，直到查到全局上下文为止。3.作用域和上下文的區別作用域在函数定义的时候就已经确定了，上下文要在函数调用执行阶段才确定。 extra我发现有时候想要深入了解一些原理，只靠一本书是不够的，还要翻阅多本书，多个文档。如果不好理解，还需要去看一下别人的博客，看看他们怎么理解。感谢前辈们的贡献 参考链接JavaScript深入之词法作用域和动态作用域JavaScript深入之执行上下文","categories":[],"tags":[]},{"title":"JS中的面向对象，原型链和继承","slug":"JS中的面向对象，原型链和继承","date":"2018-10-31T07:06:04.192Z","updated":"2018-10-31T07:06:47.148Z","comments":true,"path":"2018/10/31/JS中的面向对象，原型链和继承/","link":"","permalink":"http://yoursite.com/2018/10/31/JS中的面向对象，原型链和继承/","excerpt":"","text":"JS中的面向对象，原型链和继承 面向对象理解只是我自己目前的一些理解，以后也许会修改。面向对象是一种抽象方式。把现实生活中的物体看作一个个‘对象’，这样我们在写实际应用的时候，就可以将现实生活中的 概念/模型 映射到计算机领域的数据结构。具有类似属性一些物体我们就将它们归为一类，产生类的概念。而被归为一类的物体中，里面还有一些物体它们也有相似的地方，还可以抽象成一个类，这样就形成父类和子类，也就引出了继承。 JS中的面向对象JS在ES6之前没有class的机制，ES6之后实现了class，当然它的本质也是语法糖，封装起来还是不错的。不过，我们作为一个学习者，还是要学习JS封装和继承的实际实现。我推荐大家还是读一读《JavaScript 高级程序设计》中的 “面向对象的程序设计”那一章，讲的还是不错的。我会挑我觉得比较经典的谈谈我的看法。 创建对象/封装虽然ES6之前没有class,但是object本身就是js基本类型之一。当然我们不可能每一次都用字面量或者Object()构造对象。所以我们引入了设计模式。像工厂模式，构造函数模式，原型模式，组合使用构造函数模式和原型模式，动态原型模式，寄生构造函数模式，稳妥构造模式。我个人还是倾向组合使用构造函数和原型模式。不过在讲之前我们先来说一下构造函数和原型。 构造函数123456function User (id, balance = 0) &#123; this.id = id; this.balance = balance;&#125;var user1 = new User(1, 100); // 像这样一个函数就是一个构造函数，它构造出来的对象 比如User1，检查 User1 instanceof User 返回为true。 使用new创建对象的过程是怎样的呢，这有时也会作为面试题被问到 new 新建一个空的Object 将构造函数的作用域赋给新对象，改变this的指向 执行构造函数 返回修改后的对象 原型你看，我们都打算将一部分具有类似属性和方法的对象抽象出来了，那些类似的属性和方法总不能还由那些对象自己放着吧，那样多浪费内存啊。我们得将类似的属性和方法放到一个地方，这些对象都能访问到，所以prototype（原型）就出场了。 prototype是每个函数都会有的属性，它指向一个Prototype对象，该原型对象也有一个constructor属性指向相应的函数。用构造函数构造出来的对象除了构造函数中添加的那些属性，还有一个[[prototype]]属性指向，构造函数的prototype。当我们查找一个对象的属性，比如在我们的user1中找一个叫name的属性，js引擎在user1对象上找不到呀，那怎么办呢？这时，js引擎就会到[[prototype]]指向的对象上找，如果找到了就返回，没找到呢？那就沿着这个原型的[[prototype]]继续往找，直到Object.prtotype为止。 所以我们就把一些相似的属性或者方法放在prototype，如下图。那为什么下面只有一些方法放在prototype里面了。这就是组合使用构造函数和原型模式。我们不能把相同的方法放构造函数里面，这已经说过了，因为浪费内存。但是属性呢？你想啊，虽然你们都有name这个属性，如果都放prototype里面，那你们不都成一个名字了？（当然，你可以手动给新构造的函数赋值来屏蔽原型中同名的属性，也可以在构造函数中赋值来屏蔽原型中的同名属性，不过何必呢，）所以除了本来就是共享一个值的属性，属性的赋值还是得放在构造函数里。123456789101112131415function User (id, name, balance = 0) &#123; this.id = id; this.name = name; this.balance = balance;&#125;User.prototype = &#123; constructor : User, saveMoney: function (amount) &#123; this.money += amount; &#125;, withdrawMoney: function (amount) &#123; this.money -= amount; &#125;&#125; 继承JS主要通过原型链实现继承，其实如果理解了对象属性的查找就比较好理解原型链。就, 子类的prototype的[[prototype]]属性指向父类的prototype，就这样一直指指指，直到Object.prototype嘛。J S高级程序设计中讲到的继承模式有许多，我认为比较经典的是组合继承和寄生组合是继承。这里内容太多，不做细讲，推荐大家去看红宝书(再次安利) 放一下我的例子吧123456789101112131415161718192021222324252627282930function User (id, name, balance = 0) &#123; this.id = id; this.name = name; this.balance = balance;&#125;var User1 = new User(1, 100);User.prototype = &#123; constructor : User, saveMoney: function (amount) &#123; this.money += amount; &#125;, withdrawMoney: function (amount) &#123; this.money -= amount; &#125;&#125;function SuperUser (id, name, balance, vipTime) &#123; User.call(this, id, name, balance); this.vipTime = vipTime;&#125;function F () &#123;&#125;F.prototype = User.prototype;SuperUser.prototype = new F();SuperUser.prototype.constructor = SuperUser;SuperUser.prototype.getDiscount = function () &#123; console.log(&apos;get discount&apos;);&#125; 这里子类的构造函数借用了父类的构造函数，关于子类原型，先构造了一个空函数，然后将User.prototype 赋值给 F.prototype,然后将F函数创建的匿名对象赋值给子类的原型。因为子类的原型是由F函数构建的，所以constructor为F,我们不希望它这样，所以修正constructor属性，最后为子类的原型添上一些方法。 （这里只是对上面代码的说明，如果看不懂，或者有一些疑问比如为什么不直接将父类的Prototype赋给子类的prototype，还是推荐看红宝书，因为本人水平有限可能将的不是特别的好，而且真要说清楚，篇幅还蛮长的） 继承函数的封装红宝书中的寄生组合式继承 抽象出来的继承方法借用原型式中oject()函数，其实只是为了实现寄生组合式继承没必要再引入一个函数，用下面的函数也可以123456function inherits(Child, Parent) &#123; function F() &#123;&#125; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;","categories":[],"tags":[]},{"title":"$(document).ready()和window.onload()的区别","slug":"$(document).ready()和window.onload()的区别","date":"2018-10-30T08:09:25.818Z","updated":"2018-10-31T07:01:07.427Z","comments":true,"path":"2018/10/30/$(document).ready()和window.onload()的区别/","link":"","permalink":"http://yoursite.com/2018/10/30/$(document).ready()和window.onload()的区别/","excerpt":"","text":"$(document).ready()和window.onload()的区别 $(document).ready()和window.onload()的区别首先 $(document).ready() 是JQuery中的方法12345678$(function()&#123;&#125;);jQuery(document).ready(function()&#123;&#125;);$(document).ready(function()&#123;&#125;);$(document).on(&apos;ready&apos;, function()&#123;&#125;); 这四种事件是一样的$可以换成JQuery，document是默认对象，ready是默认事件，可以不写 $(document).ready()在dom构建完成之后执行而 window.onload()则在页面所有资源加载完成后执行window.onload()触发发生在$(document).ready()之后 PS这篇文章其实我也没写下什么又用的东西，可能是最近感觉自己好多东西不会，有些急了，还是要调整好心态呀 :)anyway，还是可以参考下面的链接，写的还是不错的。 参考链接jQuery - What are differences between \\$(document).ready and $(window).load? - Stack Overflow简述domready和onload事件的区别 - 简书document.ready和window.onload的区别 - Hopefully Sky的博客 - CSDN博客","categories":[],"tags":[]},{"title":"谈谈 事件","slug":"谈谈 事件","date":"2018-10-24T06:07:10.540Z","updated":"2018-10-24T06:16:21.749Z","comments":true,"path":"2018/10/24/谈谈 事件/","link":"","permalink":"http://yoursite.com/2018/10/24/谈谈 事件/","excerpt":"","text":"谈谈 事件 最近在读红宝书，就是那本JavaScript高级程序设计。读到事件那一章，碰巧又看到一部分和事件有关的面试题，于是写下这篇文章当作自己的学习笔记。 事件流 在没有阅读相关文章之前，我都一直以为一个元素的onclick就只是对应这个元素的点击事件。红宝书中提出的问题就是 当你单击了某个元素时，是否也点击了它的父元素呢？当然，原文是用同心圆来做说明的。想象一张纸上有一组同心圆，当你把手放在圆心时，手指指向的不是一个圆，而是纸上所有的圆。事件流描述的是从页面接受事件的顺序。IE事件流是事件冒泡，即从最具体的元素，逐级向上传播。NetScape提出的事件流是事件捕获，即从不太具体的元素到具体的元素。而 DOM2级事件 规定的事件流包括三个阶段： 事件捕获阶段，处于目标阶段和事件冒泡阶段。 事件代理，事件委托 理解了事件流之后，其实就比较好理解事件代理。什么是事件代理呢？举个例子，我们有一个5*5的table,我们要实现一个功能就是点击某个tablecell时，将里面的文本经过某些处理输出到控制台。如果不使用事件代理，那么我们很可能写一个循环，然后对每一个tablecell设置onclick。这样当然可以，但是要知道添加到页面上的数据处理程序数量将直接影响到页面整体的性能。在循环里面为每个dom设置匿名函数显然是不可取的，这会消耗大量的内存。当然，你也可以提前写好一个通用的函数，再在循环中将函数绑定到相应的事件中。但是多次dom访问操作也是极其消耗性能的，所以事件委托是一个较好的方案。事件委托利用了事件冒泡，指定一个事件处理程序，就可以管理某一类型的所有事件。比如之前的例子，我们就写一个通用的处理函数，然后让table去监听click事件，在table的事件监听器中处理函数。而且使用事件委托之后，一旦你想要添加新的元素进去，它也能正常响应原先的事件。如果不用事件响应的话，添加dom之后，还得再次手动为这些dom添加事件处理程序。 绑定事件的方式绑定事件有三种方式。第一种是在html中进行事件绑定，即在html标签的onclick等等属性上绑定事件。这种方式会导致一个问题就是html代码和js代码紧密耦合，不利于维护。第二种是 DOM0级事件处理程序，即在dom元素的expando属性上绑定。如 var a = document.getElementById(&#39;app&#39;); a.onclick = someFunction();这种形式绑定事件不如DOM2级，因为容易导致事件相互覆盖。第三种 是DOM2级事件处理程序,如var btn = document.getElementById(&#39;myBtn&#39;); btn.addEventListener(&quot;click&quot;, function() { alert(this.id); }, false);最后一个参数建议尽量使用false，因为：标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。同时，建议在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。 Some我们可以使用 event.preventDafault()方法阻止默认事件。如果想查看默认事件是否被阻止了，可以使用event.defaultPrevented属性查看。 如果需要阻止事件的传播，可以使用event.stopPropagation()方法。","categories":[],"tags":[]},{"title":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","slug":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","date":"2018-10-14T04:40:38.662Z","updated":"2018-10-14T04:52:55.111Z","comments":true,"path":"2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","link":"","permalink":"http://yoursite.com/2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","excerpt":"","text":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题 还记得刚开始接触前端的时候，那时候第一次看到 0.1 + 0.2 !== 0.3 的时候还是比较惊讶的，但那时候的我一心只想学习一些新技术、新框架，只想快速上手，自动地把这些问题归为底层的问题，便抛之脑后了。等到再一次碰到类似的问题，已经是几个月后了。 Number的存储 在讨论为什么 0.1 + 0.2 !== 0.3 之前，我们先来看看数字在JS中是怎么存储的吧。我们都知道在JS中数字只有一种数据类型就是 Number， 而 Number 实际上是一种双精度浮点数的数据类型，遵循(IEEE - 754)标准 ，用64bit进行存储。 双精度浮点数存储格式 从左往右依次为sign bit(符号): 用来表示正负号 exponent(指数): 用来表示次方数 mantissa(尾数): 用来表示精确度 在我不了解它的数字表示之前，我考虑的是mantissa表示尾数，那么小数点应该存放在哪里，怎么存放？后来，我才明白，小数点不用存，你可以把它看成小数点在尾数mantissa的最左边，即52bit和51bit之间，为什么会这样呢？ 事实上，为了最大限度提高精确度，可以要求尾数规格化，把尾数处理到大于等于1而小于2的区间内，便可省去前述的“1” 相当于尾数mantissa部分左侧多了一个“1.”还不用占用空间。比如尾数mantissa中存了52个1那么尾数mantissa实际表示的值（二进制）即为1.11…111(小数点后52个1)$$ mantissa = 1.11…111 $$转换成十进制即$$ mantissa = 1+ (1/2)^1 + (1/2)^2 + … + (1/2)^{51} + (1/2)^{52} $$ 与此同时，我们正常理解指数部分应该为$$ 2^{exponent} $$exponent即为62bit到52位的正常二进制表示但实际上我们的exponent 还有一个片偏移量所以指数部分实际表示的值还要减去0x3ff那么指数部分实际表示的值为$$ 2^{exponent-0x3ff} $$ 那么这64bit实际表示的数字为$$ (-1)^{sign} \\times 1.mantissa \\times 2^{exponent-0x3ff} $$ 回到 0.1 + 0.2 那么回到 0.1 + 0.2 这个问题上，我们看看0.1和0.2实际存储情况是怎么样的。我们先看0.1123456789101112130.1 * 2 = 0.2 //00.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //0... 你可以看到它是乘不完的，0011这四个数在循环，即0.1转换成二进制是无限循环的。但是要知道，我们的尾数部分只有52位，多的部分只能截掉。也就是说十进制的0.1在存储为双精度浮点数的时候会造成精度丢失。 而精度丢失丢失正是我们今天这个问题的原因所在1234567// 0.1 的存储形式0.00011001100110011001100110011001100110011001100110011010 // 0.2 的存储形式0.0011001100110011001100110011001100110011001100110011010 // 二进制相加的结果0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 其他语言的通病 事实上，这不是JS才有的问题，毕竟Number类型是按照IEEE - 754标准的双精度浮点数实现的，这个问题在所有按照标准实现的语言中都有可能出现。 在我前一段时间写的项目中，我发现表格中一个金额显示为“30635.839999999997”，想了一会觉得应该是JavaScipt中Number丢失精度的问题。后来查看日志发现不是，而是Rails后端接口传过来的数据就是“30635.839999999997”，在后端进行double类型相加运算的时候，就已经出现了问题。起码这已经能证明这个问题不是JavaScript的原因。 解决问题案例 正如上面提到的那样，我之前的一个项目中，发现表格中一个金额显示为“30635.839999999997”，这个显示数据肯定不行的。发现之后，我一开始打算直接粗暴地给表格所有数据加上toFixed(2)完事，这样的修改是最不用动脑子的。但是这样是行不通的，一个是我想要整数和一位小数只显示他们原来的样子。比如“500”就显示成“500”而不是”500.00”。另外toFixed()方法本身也有问题，不能正常地进行四舍五入。 这里我使用了他人的一个方法(链接位于文末)12345678910数据展示类当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True封装成方法就是：function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision));&#125;为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。 我在js需要处理相关数据的地方中调用这个函数，大体是能解决这个问题的。 当然工作中碰到精度问题的情景不可能只有这一个，如果需要专业的解决方法，我们可以使用mathjs。 不管怎么样，理解了0.1 + 0.2 !== 0.3的原因，起码以后遇到类似问题，就能快速定位到原因所在。 参考链接 双精度浮点数 - 维基百科，自由的百科全书JavaScript 浮点数陷阱及解法","categories":[],"tags":[]}]}