{"meta":{"title":"Joe的个人博客","subtitle":null,"description":null,"author":"Joe Lu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"谈谈 事件","slug":"谈谈 事件","date":"2018-10-24T06:07:10.540Z","updated":"2018-10-24T06:16:21.749Z","comments":true,"path":"2018/10/24/谈谈 事件/","link":"","permalink":"http://yoursite.com/2018/10/24/谈谈 事件/","excerpt":"","text":"谈谈 事件 最近在读红宝书，就是那本JavaScript高级程序设计。读到事件那一章，碰巧又看到一部分和事件有关的面试题，于是写下这篇文章当作自己的学习笔记。 事件流 在没有阅读相关文章之前，我都一直以为一个元素的onclick就只是对应这个元素的点击事件。红宝书中提出的问题就是 当你单击了某个元素时，是否也点击了它的父元素呢？当然，原文是用同心圆来做说明的。想象一张纸上有一组同心圆，当你把手放在圆心时，手指指向的不是一个圆，而是纸上所有的圆。事件流描述的是从页面接受事件的顺序。IE事件流是事件冒泡，即从最具体的元素，逐级向上传播。NetScape提出的事件流是事件捕获，即从不太具体的元素到具体的元素。而 DOM2级事件 规定的事件流包括三个阶段： 事件捕获阶段，处于目标阶段和事件冒泡阶段。 事件代理，事件委托 理解了事件流之后，其实就比较好理解事件代理。什么是事件代理呢？举个例子，我们有一个5*5的table,我们要实现一个功能就是点击某个tablecell时，将里面的文本经过某些处理输出到控制台。如果不使用事件代理，那么我们很可能写一个循环，然后对每一个tablecell设置onclick。这样当然可以，但是要知道添加到页面上的数据处理程序数量将直接影响到页面整体的性能。在循环里面为每个dom设置匿名函数显然是不可取的，这会消耗大量的内存。当然，你也可以提前写好一个通用的函数，再在循环中将函数绑定到相应的事件中。但是多次dom访问操作也是极其消耗性能的，所以事件委托是一个较好的方案。事件委托利用了事件冒泡，指定一个事件处理程序，就可以管理某一类型的所有事件。比如之前的例子，我们就写一个通用的处理函数，然后让table去监听click事件，在table的事件监听器中处理函数。而且使用事件委托之后，一旦你想要添加新的元素进去，它也能正常响应原先的事件。如果不用事件响应的话，添加dom之后，还得再次手动为这些dom添加事件处理程序。 绑定事件的方式绑定事件有三种方式。第一种是在html中进行事件绑定，即在html标签的onclick等等属性上绑定事件。这种方式会导致一个问题就是html代码和js代码紧密耦合，不利于维护。第二种是 DOM0级事件处理程序，即在dom元素的expando属性上绑定。如 var a = document.getElementById(&#39;app&#39;); a.onclick = someFunction();这种形式绑定事件不如DOM2级，因为容易导致事件相互覆盖。第三种 是DOM2级事件处理程序,如var btn = document.getElementById(&#39;myBtn&#39;); btn.addEventListener(&quot;click&quot;, function() { alert(this.id); }, false);最后一个参数建议尽量使用false，因为：标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。同时，建议在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。 Some我们可以使用 event.preventDafault()方法阻止默认事件。如果想查看默认事件是否被阻止了，可以使用event.defaultPrevented属性查看。 如果需要阻止事件的传播，可以使用event.stopPropagation()方法。","categories":[],"tags":[]},{"title":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","slug":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","date":"2018-10-14T04:40:38.662Z","updated":"2018-10-14T04:52:55.111Z","comments":true,"path":"2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","link":"","permalink":"http://yoursite.com/2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","excerpt":"","text":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题 还记得刚开始接触前端的时候，那时候第一次看到 0.1 + 0.2 !== 0.3 的时候还是比较惊讶的，但那时候的我一心只想学习一些新技术、新框架，只想快速上手，自动地把这些问题归为底层的问题，便抛之脑后了。等到再一次碰到类似的问题，已经是几个月后了。 Number的存储 在讨论为什么 0.1 + 0.2 !== 0.3 之前，我们先来看看数字在JS中是怎么存储的吧。我们都知道在JS中数字只有一种数据类型就是 Number， 而 Number 实际上是一种双精度浮点数的数据类型，遵循(IEEE - 754)标准 ，用64bit进行存储。 双精度浮点数存储格式 从左往右依次为sign bit(符号): 用来表示正负号 exponent(指数): 用来表示次方数 mantissa(尾数): 用来表示精确度 在我不了解它的数字表示之前，我考虑的是mantissa表示尾数，那么小数点应该存放在哪里，怎么存放？后来，我才明白，小数点不用存，你可以把它看成小数点在尾数mantissa的最左边，即52bit和51bit之间，为什么会这样呢？ 事实上，为了最大限度提高精确度，可以要求尾数规格化，把尾数处理到大于等于1而小于2的区间内，便可省去前述的“1” 相当于尾数mantissa部分左侧多了一个“1.”还不用占用空间。比如尾数mantissa中存了52个1那么尾数mantissa实际表示的值（二进制）即为1.11…111(小数点后52个1)$$ mantissa = 1.11…111 $$转换成十进制即$$ mantissa = 1+ (1/2)^1 + (1/2)^2 + … + (1/2)^{51} + (1/2)^{52} $$ 与此同时，我们正常理解指数部分应该为$$ 2^{exponent} $$exponent即为62bit到52位的正常二进制表示但实际上我们的exponent 还有一个片偏移量所以指数部分实际表示的值还要减去0x3ff那么指数部分实际表示的值为$$ 2^{exponent-0x3ff} $$ 那么这64bit实际表示的数字为$$ (-1)^{sign} \\times 1.mantissa \\times 2^{exponent-0x3ff} $$ 回到 0.1 + 0.2 那么回到 0.1 + 0.2 这个问题上，我们看看0.1和0.2实际存储情况是怎么样的。我们先看0.1123456789101112130.1 * 2 = 0.2 //00.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //0... 你可以看到它是乘不完的，0011这四个数在循环，即0.1转换成二进制是无限循环的。但是要知道，我们的尾数部分只有52位，多的部分只能截掉。也就是说十进制的0.1在存储为双精度浮点数的时候会造成精度丢失。 而精度丢失丢失正是我们今天这个问题的原因所在1234567// 0.1 的存储形式0.00011001100110011001100110011001100110011001100110011010 // 0.2 的存储形式0.0011001100110011001100110011001100110011001100110011010 // 二进制相加的结果0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 其他语言的通病 事实上，这不是JS才有的问题，毕竟Number类型是按照IEEE - 754标准的双精度浮点数实现的，这个问题在所有按照标准实现的语言中都有可能出现。 在我前一段时间写的项目中，我发现表格中一个金额显示为“30635.839999999997”，想了一会觉得应该是JavaScipt中Number丢失精度的问题。后来查看日志发现不是，而是Rails后端接口传过来的数据就是“30635.839999999997”，在后端进行double类型相加运算的时候，就已经出现了问题。起码这已经能证明这个问题不是JavaScript的原因。 解决问题案例 正如上面提到的那样，我之前的一个项目中，发现表格中一个金额显示为“30635.839999999997”，这个显示数据肯定不行的。发现之后，我一开始打算直接粗暴地给表格所有数据加上toFixed(2)完事，这样的修改是最不用动脑子的。但是这样是行不通的，一个是我想要整数和一位小数只显示他们原来的样子。比如“500”就显示成“500”而不是”500.00”。另外toFixed()方法本身也有问题，不能正常地进行四舍五入。 这里我使用了他人的一个方法(链接位于文末)12345678910数据展示类当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True封装成方法就是：function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision));&#125;为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。 我在js需要处理相关数据的地方中调用这个函数，大体是能解决这个问题的。 当然工作中碰到精度问题的情景不可能只有这一个，如果需要专业的解决方法，我们可以使用mathjs。 不管怎么样，理解了0.1 + 0.2 !== 0.3的原因，起码以后遇到类似问题，就能快速定位到原因所在。 参考链接 双精度浮点数 - 维基百科，自由的百科全书JavaScript 浮点数陷阱及解法","categories":[],"tags":[]}]}