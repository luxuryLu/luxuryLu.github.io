{"meta":{"title":"Joe的个人博客","subtitle":null,"description":null,"author":"Joe Lu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","slug":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题","date":"2018-10-14T04:40:38.662Z","updated":"2018-10-14T04:52:55.111Z","comments":true,"path":"2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","link":"","permalink":"http://yoursite.com/2018/10/14/从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题/","excerpt":"","text":"从 0.1 + 0.2 !== 0.3 开始 谈谈JavaScript精度问题 还记得刚开始接触前端的时候，那时候第一次看到 0.1 + 0.2 !== 0.3 的时候还是比较惊讶的，但那时候的我一心只想学习一些新技术、新框架，只想快速上手，自动地把这些问题归为底层的问题，便抛之脑后了。等到再一次碰到类似的问题，已经是几个月后了。 Number的存储 在讨论为什么 0.1 + 0.2 !== 0.3 之前，我们先来看看数字在JS中是怎么存储的吧。我们都知道在JS中数字只有一种数据类型就是 Number， 而 Number 实际上是一种双精度浮点数的数据类型，遵循(IEEE - 754)标准 ，用64bit进行存储。 双精度浮点数存储格式 从左往右依次为sign bit(符号): 用来表示正负号 exponent(指数): 用来表示次方数 mantissa(尾数): 用来表示精确度 在我不了解它的数字表示之前，我考虑的是mantissa表示尾数，那么小数点应该存放在哪里，怎么存放？后来，我才明白，小数点不用存，你可以把它看成小数点在尾数mantissa的最左边，即52bit和51bit之间，为什么会这样呢？ 事实上，为了最大限度提高精确度，可以要求尾数规格化，把尾数处理到大于等于1而小于2的区间内，便可省去前述的“1” 相当于尾数mantissa部分左侧多了一个“1.”还不用占用空间。比如尾数mantissa中存了52个1那么尾数mantissa实际表示的值（二进制）即为1.11…111(小数点后52个1)$$ mantissa = 1.11…111 $$转换成十进制即$$ mantissa = 1+ (1/2)^1 + (1/2)^2 + … + (1/2)^{51} + (1/2)^{52} $$ 与此同时，我们正常理解指数部分应该为$$ 2^{exponent} $$exponent即为62bit到52位的正常二进制表示但实际上我们的exponent 还有一个片偏移量所以指数部分实际表示的值还要减去0x3ff那么指数部分实际表示的值为$$ 2^{exponent-0x3ff} $$ 那么这64bit实际表示的数字为$$ (-1)^{sign} \\times 1.mantissa \\times 2^{exponent-0x3ff} $$ 回到 0.1 + 0.2 那么回到 0.1 + 0.2 这个问题上，我们看看0.1和0.2实际存储情况是怎么样的。我们先看0.1123456789101112130.1 * 2 = 0.2 //00.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //00.4 * 2 = 0.8 //00.8 * 2 = 1.6 //10.6 * 2 = 1.2 //10.2 * 2 = 0.4 //0... 你可以看到它是乘不完的，0011这四个数在循环，即0.1转换成二进制是无限循环的。但是要知道，我们的尾数部分只有52位，多的部分只能截掉。也就是说十进制的0.1在存储为双精度浮点数的时候会造成精度丢失。 而精度丢失丢失正是我们今天这个问题的原因所在1234567// 0.1 的存储形式0.00011001100110011001100110011001100110011001100110011010 // 0.2 的存储形式0.0011001100110011001100110011001100110011001100110011010 // 二进制相加的结果0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 其他语言的通病 事实上，这不是JS才有的问题，毕竟Number类型是按照IEEE - 754标准的双精度浮点数实现的，这个问题在所有按照标准实现的语言中都有可能出现。 在我前一段时间写的项目中，我发现表格中一个金额显示为“30635.839999999997”，想了一会觉得应该是JavaScipt中Number丢失精度的问题。后来查看日志发现不是，而是Rails后端接口传过来的数据就是“30635.839999999997”，在后端进行double类型相加运算的时候，就已经出现了问题。起码这已经能证明这个问题不是JavaScript的原因。 解决问题案例 正如上面提到的那样，我之前的一个项目中，发现表格中一个金额显示为“30635.839999999997”，这个显示数据肯定不行的。发现之后，我一开始打算直接粗暴地给表格所有数据加上toFixed(2)完事，这样的修改是最不用动脑子的。但是这样是行不通的，一个是我想要整数和一位小数只显示他们原来的样子。比如“500”就显示成“500”而不是”500.00”。另外toFixed()方法本身也有问题，不能正常地进行四舍五入。 这里我使用了他人的一个方法(链接位于文末)12345678910数据展示类当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True封装成方法就是：function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision));&#125;为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。 我在js需要处理相关数据的地方中调用这个函数，大体是能解决这个问题的。 当然工作中碰到精度问题的情景不可能只有这一个，如果需要专业的解决方法，我们可以使用mathjs。 不管怎么样，理解了0.1 + 0.2 !== 0.3的原因，起码以后遇到类似问题，就能快速定位到原因所在。 参考链接 双精度浮点数 - 维基百科，自由的百科全书JavaScript 浮点数陷阱及解法","categories":[],"tags":[]}]}